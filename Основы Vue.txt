Основы Vue.
Vue берет все внутри элемента #app в html файле и преобразует в html, который передается браузеру. Внутри элемента код понятный для Vue, но не (html) для браузера.
new Vue({
  el: '#app',
  data: {
	url: 'http://google.com',
    link: '<a href="http://google.com">Google</a>'
  },
  methods: {
	name: function(){}
  }
})
Внутри скобок {{ }} вычисляются javascript выражения (=> там можно вызвать метод, он должен возвращать тип, который можно преобразовать в строку).
<h1>Sum: {{ 60 + 10 }}</h1>
Для атрибутов так же можно писать javascript выражения, для этого используется директива v-bind. 
<a v-bind:href="url">{{ url }}</a> Сокращенная запись: v-bind:href="url" => :href="url"
Для вывода html кода - атрибут v-html, html будет встроен внутри тега. Есть опасность инъекций.
<h2 v-html="link"></h2> => <h2><a href="http://google.com">Google</a></h2>

События: v-on:event_name="function_name". В функцию передается стандарный объект события в качестве аргумента. (event.target.style.color = 'red').
Передача параметров: v-on:click="riseCounter(5, 'Изменено на 5', $event)" 
Сокращенная запись: @click="riseCounter(5, 'Изменено на 5', $event)"

Модификаторы событий. Если нужно отменить стандартное поведение ссылки (отменить переход):
<a href="http://google.com" target="_blank" v-on:click="clickOnGoogle">Google</a>
clickOnGoogle: function(event){
	event.preventDefault()
}
У Vue для этих случаев есть специальный модификатор:
<a href="http://google.com" target="_blank" v-on:click.prevent="">Google</a>
.prevent - preventDefault
.stop - stopPropagation
<h2 v-on:mousemove="handleMouseMove">
	X: {{ x }} \ Y: {{ y }}
	<span v-on:mousemove.stop="">Не изменять</span>
</h2>
handleMouseMove: function (event) {
  this.x = event.clientX
  this.y = event.clientY
}
Можно указывать любое количество модификаторов через точку:
<input type="text" v-on:keyup.enter.space="alertValue"> - событие keyup сработает если нажать клавишу интер или пробел.

Модель для работы с формами. 
Двустароннее связывание: <input type="text" v-model="inputValue">
Связывание срабатывающее при потере фокуса: <input type="text" v-model.lazy="inputValue">

Работа с CSS классами.
<div
	class="circle"
	@click="isActive = !isActive"
	:class="getCssClasses" // :class="{	'red': this.isActive, 'green': !this.isActive }"
></div>
<div class="circle" :class="color"></div>
<div class="circle" :class="[color, {'red': isActive}]"></div>
<input type="text" v-model="color">

<script>new Vue({
  el: '#app',
  data: {
	isActive: false,
	color: 'blue'
  },
  computed: {
	getCssClasses: function() {
	  return {
		'red': this.isActive,
		'green': !this.isActive
	  }
	}
  }
})</script>

Тоже самое с атрибутом style.
<div class="circle" :style="circleClasses"></div>
<div class="circle" :style="[circleClasses, {'width': height + 'px'}]"></div>
<hr>
<input type="text" v-model="color">
<input type="text" v-model="height">
computed: {
	circleClasses: function() {
	  return {
		'background': this.color,
		'height': this.height + 'px'
	  }
	}
}

Управление видимостью элементов.
<h2 v-if="isVisible">I am visible!</h2>
<h2 v-else>No I am not!</h2>

<h2 v-if="type === 'a'">A</h2>
<h2 v-else-if="type === 'b'">B</h2>
<h2 v-else-if="type === 'c'">C</h2>
<h2 v-else>not match</h2>

Чтобы сгруппировать несколько тегов можно использовать html5 тег <template></template>
<template v-if="isVisible">
	<h2>header</h2>
	<p>Some text</p>
</template>
v-if удаляет элемент из DOM дерева, v-show добавляет style="display: none;" чтобы скрыть элемент.

Работа со списками.
В v-for можно использовать in и of: v-for="(el, index) in array" или v-for="(el, index) of array"
перебор чисел: <li v-for="num of 4">{{ num }}</li>
перебор полей объекта: <li v-for="(value, key, index) in object">
<ul>
	<li v-for="(person, index) of people">{{ index + 1 }}. {{ person.name }} - <b>{{ person.age }}</b></li>
</ul>
<hr>
<ol>
	<li v-for="num of 4">{{ num }}</li>
</ol>
<hr>
<ul>
	<li v-for="(value, key, index) in person"><em>{{ index + 1 }}</em> <b>{{ key }}</b> {{ value }}</li>
</ul>
<script>data: {
  people: [
	{name: 'Vlad', age: 20},
	{name: 'Max', age: 25},
	{name: 'Elena', age: 30}
  ],
  person: {
	name: 'Max',
	age: 50,
	job: 'Frontend'
  }
}</script>

Оптимизация приложения с computed.
Функции из свойства methods вызываются при обновлении интерфейса, даже если обновляется та часть, которая не связана с данной функцией. Свойство computed позволяет сделать так, чтобы функции, которые не зависят от изменившихся переменных не вызывались. Т.е. если изменются переменные которые не используются внутри функции, функция не вызывается.

<h2>Counter {{ counter }} \ {{ counter2 }}</h2>
<h3>Result: {{ result() }}</h3>
<h3>Computed result: {{ computedResult }}</h3>

<button @click="add">Add</button>
<button @click="sub">Sub</button>
<button @click="counter2++">Add counter 2</button>
<script>new Vue({
el: '#app',
data: {
  counter: 0,
  counter2: 0
},
methods: {
  add: function() {
	this.counter++
  },
  sub: function() {
	this.counter--
  },
  result: function() { // вызывается при изменении counter2
	console.log('Result was called')
	return this.counter > 3 ? 'More than 3' : 'Less than 3'
  }
},
computed: {
  computedResult: function() { // не вызывается при изменении counter2
	console.log('Computed result was called') 
	return this.counter > 3 ? 'More than 3' : 'Less than 3'
  }
},
watch: {
  counter: function(val) {
    console.log('From watch object', val)
  }
}
})</script>

Отслеживание изменений с watch.
Свойство watch позволяет следить за изменением полей, которые есть в свойстве data. Для этого в нем определяются функции названия которых совпадают с названием поля в свойстве data. Функция будет вызываться при изменении поля. Аргументом получает отслеживаемый объект.

Связывание разных приложений. Инстанс vue.
<div id="app">
	<h2>{{ title }}</h2>
	<h3>{{ newField }}</h3>
	<button @click="title = 'Updated title'">Update title</button>
</div>
<hr>
<div id="app2">
	<h2>{{ title }}</h2>
	<button @click="updateFirstTitle">Update first title</button>
</div>

<script src="https://cdn,jsdelivr.net/npm/vue@2.5.13/dist/vue.js"></script>
<script>
	var vue1 = new Vue({
		el: '#app',
		data: {
			title: 'Hello I am Vue!'
		},
		methods:{
			alertFast: function(){
				alert('I am from vue 1');
			}
		}
	});
	vue1.newField = 'Random text'; // не сработает, т.к. приложение уже проинициализировано. Обновится при изменении других полей
	console.log(vue1);
	new Vue({
		el: 'app2',
		data: {
			title: 'Hello from Vue 2'
		},
		methods: {
			updateFirstTitle: function(){
				vue1.title = 'Updated from second app';
				vue1.newField = 'New field from second app'; // сработает
				
				setTimeout(function(){
					vue1.alertFast();
				}, 1000);
			}
		}
	});
</script>
Можно создавать сколько угодно инстансов Vue, каждый будет привязан к своему элементу по id. 
Для взаимодействия между инстансами их можно присваивать переменным и обращаться к их полям из других инстансов Vue. Так же можно добавлять новые поля через переменную.
Чтобы кнопка во втором приложении могла изменять title в первом нужно в методе второго обратиться к полю первого.

Доступ к DOM элементам.
Осуществляется с помощью атрибута ref. В объекте vue есть стандартные поля которые начинаются с $, доступ к DOM элементу из медтода осуществляется через this.$refs. Референсы используют виртуальный DOM, который строит vue.js и работают быстрее стандартных методов document.querySelector('h2');
<h2 ref="heading">{{ title }}</h2>
methods: {
	updateFirstTitle: function(){
		this.title = 'New title!';
		this.$refs.heading.style.color = 'red';
		console.log(this.$refs);
		console.log(this.$refs.heading);
	}
	
}

Свойство template.
Другой способ инициализации приложения без указания свойства el в объекте vue. После формирования готового объекта vue, его можно инициализировать в шаблоне с помощью метода $mount(element_css_selector). При указании поля el и css селектора, за кулисами vue делает тоже самое: $mount(el).
Свойство template позволяет указывать строковый шаблон не в html'е, а внутри javascript'а. Огранечение: должен быть корневой элемент (например <div></div>) который оборачивает весь остальной контент.
<div id="app">
	<h2>{{title}}</h2>
</div>
<script>
var vue = new Vue({ //нет поля el
	data: {
		title: 'Hello I am Vue!';
	},
	template: '<h1>{{title}} From template!</h1>'
});
vue.$mount('#app');
</script>

Жизненный цикл.
Можно следить за этапами жизненного цикла инстанса vue:
- beforeCreate - вызывается когда прошла инициализация и vue готовится создать новое приложение;
- created - на этом этапе vue приложение уже будет создано. На данном этапе еще не было создания html кода. Vue приложение было создано и после этого оно будет анализировать шаблон;
- beforeMount - vue начало анализировать шаблон и собирается его вставить в элемент который является точкой инициализации приложения (указанный в поле el). Т.е. Vue готовится вставить скомпилированный шаблон в DOM дерево.
- mounted - html дерево готово и вставлено в dom.

Дополнительные этапы, которые вызываются перед тем как что-то изменилось и как что-то закончило изменяться (чтобы они сработали нужно например нажать на кнопку):
- beforeUpdate - vue говорит о том что сейчас оно будет обновляться (title еще не изменился).
- updated - изменения закончены, шаблон перерисован.

Этапы помогающие отслеживать удаление или уничтожение компонета vue:
- beforeDestroy - 
- destroyed - вызовется когда инстанс удалится.
Для доступа к функциям, которые вызываются в различные этапы жц приложения они определяются в объекте vue.
<div id="app">
	<h2>{{ title }}</h2>
	<button @click="title = 'Updated title'">Update title</button>
	<button @click="doDestroy">Destroy</button>
</div>
<script>
var vue = new Vue({ //нет поля el
	el: '#app',
	data: {
		title: 'Hello I am Vue!';
	},
	methods:{
		doDestroy: function(){
			this.$destroy(); // уничтожает приложение и освобождает память
		}
	},
	beforeCreate: function(){
		console.log('Before create');
	}
	created: function(){
		console.log('Created');
	}
	beforeMount: function(){
		console.log('Before mount');
	},
	mounted: function(){
		console.log('Mounted');
	},
	beforeUpdate: function(){
		console.log('Before update');
	},
	updated: function(){
		console.log('Updated');
	},
	beforeDestroy: function(){
		console.log('Before destroy');
	},
	destroyed: function(){
		console.log('Destroyed');
	}
});
</script>

Зачем нужен CLI.
Позволяет разворачивать проекты на vue.js. При создании приложения код организуется в соответствии с определенной структурой. Код разбивается на компонеты и файлы, т.е. делается декомпозиция. Проекты сгенерированные с помощью cli поддерживают автоперезагрузку (hot reload - перезагрузка страницы в браузере при изменении файла на диске), перезагрузку модулей, препроцессоры, готовый сервер для работы с апи... Для работы требуется node.js.

Установка CLI и создание проекта.
https://github.com/vuejs/vue-cli/tree/master
$ npm install -g vue-cli

создание проекта
vue init <template-name> <project-name>
<project-name> - название проекта, так будет называться папка которую создаст vue cli
<template-name> - шаблон проекта, существует несколько стандартных шаблонов.

vue init webpack-simple vue-project


Структура проекта.
package.json - используемые npm пакеты.
- dependences -  production зависимости. 
- devDependences - пакеты для разработки.
-? scripts - скрипты dev и build. dev - нужен чтобы запустить разработку приложения. Build - нужен чтобы собрать приложение без модулей, библиотек и с минифицированием кода.
.babelrc - отвечает за компиляцию в EcmaScript 6. Показывает какие правила нужно учитывать при компиляции.
.editorconfig - в разных редакторах разные правила редактирования, чтобы проект писался в одном стиле в этом файле содержатся общие настройки: величина отступов, символ табуляции (пробел или tab) и т.д.
.gitignore - говорит какие файлы не нужно включать в систему контроля версий.
index.html - мастер страница.
webpack.config.js
src - исходный код приложения.
main.js - Основной файл, который запускает приложение.
App.vue - компонент где описана логика приложения.
Файл формата *.vue содержит 3 секции:
- <template></template> - html шаблон. Обязательный.
- <script></script> - js код. Не обязательный.
- <style></style> - стили компонента. Не обязательный.

Для запуска проекта нужно воспользоваться скриптами, которые описаны в файле package.json.
Перейти в папку проекта (папка в которой лежит package.json).
npm run dev

Как запускается приложение.
main.js - точка входа в приложение
import Vue from 'vue';
import App from './App.vue'; // импорт компонента App
new Vue({
	el: '#app', // <div id="app"></div> находится в файле index.html
	render: h => h(App)
});

render - функция, которая принимает другую функцию h как параметр. В функцию h в качестве параметра передается vue компонет. Этот компонент будет отрисован в <div id="app"></div>, т.е. с него начнется работа приложения.
render - ключевое слово, которое есть в объекте конфигурации vue. Это функция, которая позволяет рендерить (или запускать) все приложение.

render: function(h){
	return h(App);
}

App.vue
<template>
	<h1>{{ msg }}</h1> // шаблон
</template>
<script>
// конструкция es 6
export default { // экспорт объекта
	data(){
		return {
			msg: 'Welcome to Your Vue.Js App'
		};
	}
}
</script>
export default  - экспортирует объект. В данном случае это объект конфигурации vue или отдельные компоненты.
Далее этот объект импортируется при помощи webpack лоадеров. При этом Webpack соединяет объект и шаблон.
import App from './App.vue'; 
Мы получаем App - объект конфигурации со встроенным шаблоном.


Компоненты.
Зачем нужны компоненты.
Допустим нужно сделать два независимых counter'a. Можно просто скопировать код.
Чтобы избежать повторения кода были изобретены компоненты. Компоненты это некоторые переиспользуемые элементы сайта, работающие независимо друг от друга. Их можно связывать.

Чтобы создать компонет в объекте vue есть специпльный метод component. Первый параметр - селектор при помощи которого в дальнейшем можно будет создать компонет и проинициализировать (название тега который будет использоваться), второй параметр - объект конфигурации, в котором должно быть поле template описывающее шаблон, и в отличии от обычного объекта конфигурации поле data должно быть функцией, которая возвращает значение поля data. Компоненты регистрируются до инициализации приложения. Компонент должен содержать в себе только один корневой элемент внутри тега template.

<div id="app">
	<div style="border: 1px solid black; padding: 10px"> <!-- Теперь четко видно границы элемента -->
		<h2>Counter: {{ counter }}</h2>
		<button @click="counter++">Add to counter</button>
	</div>
	<div style="border: 1px solid black; padding: 10px">
		<h2>Counter: {{ counter2 }}</h2>
		<button @click="counter2++">Add to counter</button>
	</div>
	
	<my-counter></my-counter>
	<my-counter></my-counter>
	<my-counter v-for="c in 20"></my-counter>
</div>
<script>

Vue.component('my-counter', {
	// обратные кавычки позволяют сохранять форматирование и писать код на разных строках
	template: ` 
		<div style="border: 1px solid black; padding: 10px">
			<h2>Counter: {{ counter }}</h2>
			<button @click="add">Add to counter</button>
		</div>
	`,
	data: function(){ // поле data должно быть функцией, которая возвращает значение поля data
		return {
			counter: 0
		}
	},
	methods:{
		add: function(){
			this.counter++;
		}
	}
});

new Vue({
	el: '#app',
	data: {
		counter: 0,
		counter2: 0
	}
});
</script>

Метод data.
Возвращает объект который содержит изолированные данные, которые нужны для компонента. Если бы поле data было объектом, то все компоненты ссылались бы на одни и теже данные (изменение в одном изменяло бы все компоненты), было бы нельзя работать с изолированным состоянием. Поэтому нужно писать функцию, которая возвращает новый объект. При конфигурировании vue можно было использовать data как объект, потому что это был единственный экземпляр, компоненты повторяются поэтому нужно использовать функцию.

<script>
var dataObj = {
	counter: 0
}
Vue.component('my-counter', {
	data: function(){
		return dataObj; // возвращается ссылка на переменную, а не новый объект. В любом компоненте будет один и тот же объект.
	}
});
</script>


Локальная и глобальная регистрация.
Допустим у нас два приложения. Компонент counter будет доступен в обоих приложениях, т.к. он был зарегистрирован в глобальном объекте Vue. Чтобы компоненты были доступны только в одном приложении их можно регистрировать локально в каждом экземпляре vue. Для этого есть специальное поле components - это объект в котором ключем является название компонента, а значением - объект конфигурации. Во vue.js есть возможность задавать названия компонентов в формате camelCase (слова идут друг за другом с большой буквы). При этом в шаблоне используются одинаково: 'my-counter' или myCounter => <my-counter></my-counter>.

<div id="app">
	<my-counter v-for="c in 2"></my-counter>
</div>
<hr>
<div id="app2">
	<my-counter></my-counter>
</div>
<script>

var component = { // обеъкт конфигурации компонета counter
template: ``,
methods: ...
}

Vue.component('my-counter', { // Компонент зарегистрирован глобально и будет доступен во всех приложениях.
// ...
});

new Vue({
	el: '#app',
	componets: { // регистрация локальных компонентов
		'my-counter': component // название компонету можно задать используя строку
	}
});
new Vue({
	el: '#app2',
	componets: { 
		myСounter: component // второй способ задать название компоненту используя camelCase
	}
});
</script>
 
 
Регистрация компонентов в .vue.
Чтобы легко следить за состоянием компонента, каждый компонент помещается в отдельный файл *.vue.
Car.vue
<template>
	<div>
		<h3>Name: {{ carName }}</h3>
		<p>Year: {{ carYear }}</p>
	</div>
</template>
<script>
	export default {
		data() { // тоже самое что data: function(){
			return {
				carName: 'Ford',
				carYear: 2015
			}
		
		}
	}
</script>

Регистрация компонента.
В название компонента всегда лучше добавлять префикс чтобы они не пересикались с названиями тегов html 5. Самый распространенный префикс: app.
main.js
import Car from './Car.vue'
Vue.component('app-car', Car);

Использование компонента.
App.vue
<template>
	<div> <!-- в компоненте должен быть только один корневой элемент -->
		<h1>{{ msg }}</h1>
		<app-car></app-car>
	</div>
</template>

Так же компонент можно регистрировать не глобально в файле main.js, а локально в компоненте App.vue.
<script>
	import Car from './Car.vue'
	export default {
		data: function(){
			return {
				msg: 'Welcome'
			}
		},
		components: {
			appCar: Car
		}
	}
</script>

Передача параметров компоненту.
Связывать компоненты между собой. Будем отображать название машины в компоненте App и передавать его дочернему компоненту, чтобы компонент машины не знал какое имя ему выводить. Параметры в компонент передаются в теге. Принимаемаемые компонентом параметры описываются в поле props: массив в котором в качестве элементов названия входящих параметров.

Валидация входящих параметров.
Допустим будет свойство меняющие carName на обратный порядок букв. Если в компонент будет передаваться число, а не строка, то будет ошибка. Поэтому параметры нужно валидировать. Поле props может быть объектом: ключ - название парметра, значение - тип данных. Третий вариант определения props: вместо того чтобы указывать название класса в качестве типа входного параметра, можно расширить валидацию данного параметра.

Передача параметров от дочернего компонента.
Если менять поля (полученные через входные параметры) в дочернем компоненте, то в родительском изменений поля не будет. Так происходит потому что родительский компонент не уведомляется о том, что что-то изменилось. Для таких случаев нужно создавать кастомные события в дочерних компонентах и слушать их в родительских. У каждого компонента есть специальный метод $emit('название события которое будет прослушиваться', значения_для_передачи_в_другие_компонеты), который генерирует событие, которое должны слушать родительские компоненты.
В родительском компоненте обработчик события принимает параметр $event.

Передача функции как параметра.
Альтернативный способ взаимодействия между компонентами: передавать функцию из родительского компонента в дочерний. Из родительского компонента App будет передаваться функция changeNameToAudi в дочерний компонент Car в качестве параметра changeFunc, чтобы изменить название.

Связь дочерних компонентов.
В компоненте car будет кнопка увеличивающая значение счетчика в компоненте Counter. Чтобы связать компоненты создается метод updateCounter в компоненте Car, который генерирует событие counterUpdated. Событие обрабатывается в родительском компоненте App. Для этого необходимо создать переменную со значение счетчика (counter) во всех компонентах. 
Использование event emitter.
Другой способ использовать шину событий. Для этого в файле main.js создается event emitter. В компоненте Car вызывается событе eventEmitter.$emit('counterUpdated') при этом передавать новое значение счетчика не нужно, следовательно не нужно поле counter в компонентах Car и родительском компоненте App и не нужно его передавать из App в Car, оно остается только в компоненте Counter, но уже не в виде props, а в поле data. Чтобы прослушивать событие counterUpdated, создается обработчик события в методе created (компонент создан, но не заложен в дом дерево) компонента Counter: eventEmitter.$on('evnet_name', handler), handler - функция обработчик события. 
Если вместе с событием нужно передавать данные, они передаются вторым параметром:
eventEmitter.$emit('counterUpdated', 3);
eventEmitter.$on('counterUpdated', (num) => {
			this.counter += num;
		});
Есть более удобные способы взаимосвязи компонентов.

Car.vue
<template>
	<div class="car">
		<h3>Name: {{ carName }} \ {{ reverseName }}</h3>
		<p>Year: {{ carYear }}</p>
		<button @click="changeName">Change Name</button>
		<button @click="changeFunc">Change from parent</button>
		<button @click="updateCounter">Update Counter</button>
	</div>
</template>
<script>
	import { eventEmitter } from './main'; // фигурные скобки указываются потому что в файле main.js не экспортируется что-либо по дефолту, а используется обычный экспорт, поэтому при импорте используется декомпозиция объекта

	export default {
		props: ['carName', 'carYear'], // входные параметры компонента
		// второй способ описания параметров с указанием типа данных
		props: {
			carName: String, // String - название класса, которок есть в javascript'e
			carYear: Number
		},
		// Третий вариант определения props
		props: {
			carName: {
				type: String,
				required: true,
				default: 'Default name'
			},
			carYear: Number,
			changeFunc: Function,
			counter: Number
		},
		methods: {
			changeName() {
				this.carName = 'Mazda';
				this.$emit('nameChanged', this.carName); // уведомляем другие компоненты что имя изменилось
			},
			updateCounter() {
				this.$emit('counterUpdated', this.counter + 1); // первый способ связи дочерних компонентов
				
				// второй способ с исппользованием шины событий (event emitter'a)
				eventEmitter.$emit('counterUpdated');  // не нужно передавать новое значение потому что не нужно синхронизировать три компонента
			}
		},
		computed: {
			reverseName() {
				return this.carName.split('').reverse().join('');
			}
		}
	}
</script>
<style>
	.car {
		border: 1px solid black;
	}
	.car h3 {
		margin-bottom: 5px;
	}
</style>

Counter.vue
<template>
	<h1>Counter: {{ counter }}</h1>
</template>
<script>
import { eventEmitter } from './main';
export default {
	proprs: ['counter'], // первый способ связи компонентов.
	data(){
		return {
			counter: 0	// второй способ связи компонентов
		}
	},
	created(){
		// прослушка события 
		eventEmitter.$on('counterUpdated', () => {
			this.counter++;
		});
	}
}
</script>


App.vue
<template>
	<div>
		<h1>Parent: {{ carName }}</h1>
		<app-counter :counter="counter"></app-counter>
		<app-car 
			v-bind:carName="carName" 			// <!-- Передача параметра carName -->
			v-bind:carYear="carYear"
			v-bind:counter="counter" 		// параметр для связи с компонентом Counter
			v-bind:changeFunc="changeNameToAudi" // передача функции в дочерний компонент
			v-on:nameChanged="carName = $event" // обработчик события дочернего компонента
			v-on:counterUpdated="counter = $event" 
		></app-car> 
	</div>
</template>
<script>
	import Car from './Car.vue'
	import Counter from './Counter.vue'
	export default {
		data: function(){
			return {
				carName: 'Ford from parent',
				//carName: 1000, - ошибка в компоненте: this.carName.split is not a function
				// если в компоненте параметры определены с типом данных, то ошибка будет другая: type check failed for prop "carName". Expected String, got Number
				carYear: 2018,
				counter: 0 // Параметр передаваемый в компоненты Car & Counter для их связи
			}
		},
		methods: {
			changeNameToAudi(){ // функция передаваемая в дочерний компонент
				this.carName = 'Audi';
			}
		},
		components: {
			appCar: Car,
			appCounter: Counter
		}
	}
</script>

main.js
import Vue from 'vue'
import App from './App.vue'

// использование шины событий
// т.к. данная костанта будет использоваться в компонентах, необходимо чтобы она существовала до определения всего приложения.
export const eventEmitter = new Vue(); // в классе Vue мы получаем доступ к событиям emit и on

new Vue({
	el: '#app',
	render: h => h(App)
});


Изолированные стили.
Компоненты Car и Counter имеют одинаковую разметку (див в который вложены заголовок и параграф). Если задать стили в для дива в компоненте Car, то они применятся ко всем дивам и в других компонентах. Т.е. все стили задаются глобально. У тега style есть специальный атрибут scoped, использовав который можно ограничить стили одним компонентом.
Это достигается путем добавление во все теги компонента специального атрибута data-v-{id} (для всех тегов имеет одно и тоже значение). Этот атрибут добавляется в css селекторе.
App.vue
<template>
	<div>
		<app-counter></app-counter>
		<app-car></app-car> 
	</div>
</template>
<script>
	import Car from './Car.vue'
	import Counter from './Counter.vue'
	export default {
		components: {
			appCar: Car,
			appCounter: Counter
		}
	}
</script>

Car.vue
<template>
	<div>
		<h2>Car</h2>
		<p>Some text</p>
	</div>
</template>
<script>
export default {
		
}
</script>
<style>
div { /* стиль применится ко всем дивам и в других компонентах */
	border: 1px solid black;
}
</style>

Counter.vue
<template>
	<div>
		<h2>Counter</h2>
		<p>Some text 10 words</p>
	</div>
</template>
<script>
export default {
}
</script>
<style scoped> /* данные стили будут применены локально только к данному компоненту */
	h2 {
		color: red;
	}
</style>

Передача HTML компоненту.
Для этого HTML нужно разметсить внутри тега компонента. В компоненте нужно указать куда он будет вставляться тегом <slot name="id">. Можно вставлять разметку в разные места дочернего компанента, т.е. в слоты с разным name. При передачи разметки ей указывается атрибут slot="id". В передаваемом Html могут использоваться переменные, перед передачей шаблона в компонент vue заменит интерполяцию значением переменной и передаст готовую разметку в компонент. Изолированные стили компонента App будут применены к разметке передаваемой в дочерний элемент Car. Так же к этой разметке будут применяться и изолированные стили самого компонента Car. Это достигается добавлением двух атрибутов data-v-{id} к тегам в разметке.
App.vue
<template>
	<div>
		<app-car>
			<h2 slot="title">{{carName}} + html</h2>
			<p slot="text">Some text</p>
		</app-car> 
	</div>
</template>
<script>
import Car from './Car.vue'
export default {
	data() {
		return {
			carName: 'Ford'
		}
	},
	components: {
		appCar: Car
	}
}
</script>
<style scoped>
	h2 {
		color: red;
	}
</style>
Car.vue
<template>
	<div>
		<slot name="title"></slot>
		<hr>
		<hr>
		<slot name="text"></slot>
	</div>
</template>
<script>
export default {
}
</script>
<style scoped>
div { 
	border: 1px solid black;
	padding: 10px;
}
h2 {
	font-style: italic;
}
</style>


Директивы.
<h2 v-{название}:{аргумент}.{модификатор1}.{модификатор2}="параметр"></h2>
Создание своей директивы.
Директивы это специальные атрибуты, которые могут использоваться внутри HTML шаблона чтобы взаимодействовать с html-тегами: v-on, v-bind. Директиве передаются аргументы через двоеточие: v-on:click. 
Регистрация директивы: Vue.directive('название', объект конфигурации); 
Обращение к директиве перед названием добавляется v-: <h2 v-{название}></h2>
Взаимодействие с элементом - При инициализации директивы в метод bind передается элемент к которому привязана директива: el.style.color = 'red';.
Жизненный цикл директивы.
Директива состоит из методов, которые являются различными жизненными этапами в создании и инициализации директивы. 
bind(el, bindings, vnode) - вызывается когда директива инициализируется, привязывается к элементу внутри виртуального дома. el - элемент к которому привязывается директива, bindings - свойства, передаваемые в директиву, vnode - virtual node, содержит объект виртуального дерева где будет хранится элемент директивы. bindings, vnode - read only параметры.
inserted(el, bindings, vnode) - директива находится в дом дереве.
update(el, bindings, vnode, oldVnode) - вызывается когда что-то изменяется в дом дереве, что затрагивает директиву (когда обновляется родительский компонент, но дочерние не обновились). oldVnode - старая виртуальная нода, до обновления директивы. 
componentUpdated(el, bindings, vnode, oldVnode) - вызывается после метода update, если обновились дочерние элементы, которые присутствуют у директивы.
unbind - вызывется когда директива убирается из дом дерева.

color.js
export default {
	bind(el, bindings, vnode) {
		console.log('bind');
		el.style.color = 'red';
	},
	inserted(el, bindings, vnode) {
		console.log('inserted');
	},
	update(el, bindings, vnode) {
		console.log('update');
	},
	componentUpdated(el, bindings, vnode, oldVnode) {
		console.log('componentUpdated');
	},
	unbind(){
		console.log('unbind');
	}
}

main.js
import ColorDirective from './color'

// регистрация директивы
Vue.directive('colored', ColorDirective);

App.vue
<template>
	<div>
		<h2 v-colored v-if="visible">{{ title }}</h2>
		<button @click="visible = !visible">Toggle</button>
		<button @click="title = 'New title'">Change title</button>
	</div>
</template>
<script>
export default {
	data() {
		return {
			title: 'Hello I am Vue!',
			visible: true
		}
	}
}
</script>
<style scoped>

</style>

Параметры в директивах.
Параметры передаются следующим образом v-directive_name="param"
<h2 v-colored="'green'">{{ title }}</h2>
Чтобы считать параметры из шаблона нужно обратиться к свойству bindings.value

Аргументы в директивах.
Значение после двоеточия в определении директивы называется аргументом. Например click аргумент в v-on:click
В качексьве аргумента будет передаваться свойство, к которому нужно применить цвет.
Получение доступа к аргументу в директиве: const arg = bindings.arg - здесь хранится строка указанная после двоеточия.

Модификаторы.
Передаются через точку: v-{названиеДирективы}:{аргумент}.{модификатор1}.{модификатор2}
<button v-on:click.prevent.stop="">Button</button>
Реализуем модификатор font который будет устанавливать размер шрифта в 30px.
Чтобы получить доступ к переданным модификаторам в директиве нужно обратиться к свойству bindings.modifiers - в этом объекте содержатся модификаторы в виде свойств. Модификатор в директиве принимает булевсое значение. Передан модификатор font => есть свойство bindings.modifiers.font с значением true. Желательно обращаться к названиям передаваемых модификаторов через строговое значение: bindings.modifiers['font'], потому что при компиляции есть вероятность того что название может сократиться. Например при минификации кода, а нам нужно полное совпадение названия модификатора в директиве и в шаблоне. 

Локальная регистрация.
Используется для регистрации директивы в компоненте при помощи поля directives - это объект в котором ключ - название директивы, значение - объект конфигурации. Регистрация происзодит аналогично регистрации компонентов в  свойстве components (те же правила именования).

<script>
color.js
export default {
	bind(el, bindings, vnode) {
		el.style.color = bindings.value; // считывание значения переданного в директиву
		
		const arg = bindings.arg;	
		el.style[arg] = bindings.value; // изменение цвета свойства переданного в аргументе
		
		// считывание значения модификатора
		const fontModifier = bindings.modifiers['font'];
		if (fontModifier) {
			el.style.fontSize = '30px';
		}
		
		const delayModifier = bindings.modifiers['delay']; // название модификатора долно совпадать с указанным в шаблоне, поэтому обращение через строку.
		let delay = 0;
		if (delayModifier) {
			delay = 2000;
		}
		
		setTimeout(() => {
			const arg = bindings.arg;	
			el.style[arg] = bindings.value;
		}, delay);
	}
}

main.js
import ColorDirective from './color'

// глобальная регистрация директивы для всего проекта
Vue.directive('colored', ColorDirective);
</script>

App.vue
<template>
	<div>
		<h2 v-colored="'green'">{{ title }}</h2> <!-- Передача параметра -->
		<h2 v-colored:background="'green'">{{ title }}</h2> <!-- Передача аргумента и параметра -->
		<h2 v-colored:color="'blue'">{{ title }}</h2>
		<h2 v-colored:background.font="'green'">{{ title }}</h2> <!-- Указание модификатора font -->
		<h2 v-colored:color.delay.font="'blue'">{{ title }}</h2>
		
		<h2 v-font-directive>Local font directive</h2>
	</div>
</template>
<script>
export default {
	data() {
		return {
			title: 'Hello I am Vue!',
		}
	},
	directives:{ // локальная регистрация директив
		'font-directive': {
			bind(el, bindings, vnode){
				el.style.fontsize = '40px';
			}
		},
		fontDirective:{ // название в camelCase
		}
	}
}
</script>


Фильтры и Миксины.
Создание простых фильтров.
Фильтры (pipe) позволяют преобразовывать отображение строк или элементов внутри шаблона. Фильтры могут регистрироваться локально и глобально. Локально - с помощью свойства filters в компоненте. Фильтр представляет из себя функцию в этом объекте.
{
	filters: { 
		filterName(parameter) { 
			return 'string';
		}
	}
}
Чтобы применить фильтр нужно в строке в которой используется интерполяция поставить | и далее название фильтра.
{{ expression | filter }}
Фильтры можно применять последовательно: {{ expression | filter1 | filter2 }}
Во время компиляции vue.js перед тем как вывести значение в шаблон, прогонит его через фильтр.
Глобальная регистрация:
Vue.filter({название-фильтра}, {фунция});
Изначально в vue.js нет фильтров. Все фильтры должны быть созданы самостоятельно.

Фильтрация списков.
Фильтр может применяться к массиву: <li v-for="name of names | filter">, но так лучше не делать. В vue.js есть лучшее решение, позволяющее оптимизировать приложение. Нужно воспользоваться computed свойством, которое заранее будет знать, что оно будет зависить от двух элементов (names и searchName) => фильтрация будет вызываться только при изменении этих двух элементов.

Использование миксинов.
Позволяют избежать дублирование кода в разных компонентах с одинаковой функциональностью. В нашем примере это фильтрация списка (компонент List.vue). Общий код выносится в отдельный js файл и затем импортируется в нужных местах. Для регистрации миксина в vue компоненте есть специальное свойство mixins - это массив элементы которого - миксины. После регистрации компонент может использовать в шаблоне свойства и методы определенные в миксине. Vue.js мержит значения из миксина и компонента и при конфликте приоритет получают свойства из компонента.
Если миксин зарегистрировать глобально он будет применен ко всем компонентам.


App.vue
<template>
	<div>
		<h2>{{ title }}</h2>
		<h2>{{ title | lowercase }}</h2>
		<h2>{{ title | uppercase }}</h2>
		<h2>{{ title | uppercase | lowercase }}</h2>
		
		<input type="text" v-model="searchName" >
		<ul>
			<li v-for="name of filteredNames">{{ name }}</li> <!-- Фиильтр использовать не нужно потому что есть более оптимальное решение в виде computed метода -->
		</ul>
		
		<hr>
		
		<app-list></app-list>
	</div>
</template>
<script>
export default {
	data() {
		return {
			title: 'Hello I am Vue!',
			searchName: '',
			names: ['Vlad', 'Max', 'Elena', 'Igor']
		}
	},
	computed: {
		filteredNames() { // для фильтрации массива более производительным решением будет использование computed метода вместо фильтра
			return this.names.filter(name => {
				return name.toLowerCase().indexOf(this.searchName.toLowerCase()) !== -1;
			});
		}
	},
	filters: { // в объекте filters регистрируются локальные фильтры
		lowercase(value){ 				// каждый фильтр это отдельная функция
			return value.toLowerCase();	// которая возвращает строку или другой объект валидный для использования в шаблоне
		}
	}
}

// второй способ с использованием миксина.
import ListMixin from './listMixin'
export default {
	data() {
		return {
			title: 'Hello I am Vue!',
		}
	},
	mixinss: [ListMixin],
	filters: { // в объекте filters регистрируются локальные фильтры
		lowercase(value){ 				// каждый фильтр это отдельная функция
			return value.toLowerCase();	// которая возвращает строку или другой объект валидный для использования в шаблоне
		}
	}
}
</script>

List.vue
<template>
  <div>
	<h1>List</h1>
	<input type="text" v-model="searchName" >
		<ul>
			<li v-for="name of filteredNames">{{ name }}</li> <!-- Фиильтр использовать не нужно потому что есть более оптимальное решение в виде computed метода -->
		</ul>
  </div>
</template>
<script>
// первый вариант: без миксина
export default {
	data() {
		return {
			searchName: '',
			names: ['Vlad', 'Max', 'Elena', 'Igor']
		}
	},
	computed: {
		filteredNames() { 
			return this.names.filter(name => {
				return name.toLowerCase().indexOf(this.searchName.toLowerCase()) !== -1;
			});
		}
	},
}

// второй способ с использованием миксина.
import ListMixin from './listMixin'

export default {
	mixins: [ListMixin] // регистрация миксина
}

</script>

<script>
listMixin.js
// миксин экспортирует тот же объект что был в компоненте List.vue
export default {
	data() {
		return {
			searchName: '',
			names: ['Vlad', 'Max', 'Elena', 'Igor']
		}
	},
	computed: {
		filteredNames() { 
			return this.names.filter(name => {
				return name.toLowerCase().indexOf(this.searchName.toLowerCase()) !== -1;
			});
		}
	},
}

main.js
import Vue from 'vue'
import App from './App.vue'
import List from './List.vue'

// глобальная регистрация фильтра
Vue.filter('uppercase', (value) => { 
	return value.toUpperCase(); 
});

Vue.component('app-list', List);

// глобальная регистрация миксина, т.о. данный миксин будет применен ко всем компонентам
Vue.mixin({
	beforeCreate(){
		console.log('beforeCreate');
	}
});

new Vue({
	el: '#app',
	render: h => h(App)
});
</script>


Работа с формами.
Текстовый инпут.
Модификатор lazy - меняется событие по которому меняктся инпут, изначально было событие input - реагирует на любое изменение состояния, с модификатором событие меняется на change - событие вызывается когда произошло событие change, в нашем случае это убирание фокуса с инпута

<input type="text" v-model="name">
<input type="text" v-model.lazy="name">
<p>{{ name }}</p>
export default {
	data() {
		return {
			name: 'Initial state'
		}
	}
}

Текстарея.
При взятии введенного значения из textarea будет утрачено форматирование (переход на новую строку). Существует специальный стиль который можно применить чтобы сохранить форматирование. В модели сохраняются переносы строк, но это не учитывается в параграфе(<p></p>). Чтобы это исправить ему нужно задать стиль white-space: pre; он позволяет отображать переносы строк заданные внутри модели.

<template>
	<div>
		<textarea>{{ textarea }}</textarea>
		<textarea v-model="textarea"></textarea> 
		
		<p>{{textarea}}</p> <!-- Форматирование утрачено -->
	</div>
</template>
<script>
export default {
	data() {
		return {
			textarea: 'Initial text'
		}
	}
}
</script>
<style scoped>
textarea {
	height: 100px;
	width: 400px;
}
p {
	white-space: pre;
}
</style>


Чекбоксы.
Vue.js заводит один массив, который отвечает за однотипные чекбоксы. Если значение чекбокса находися в массиве это означает, что он выбран, не находится - не выбран. Чтобы определить значение нужно написать html5 атрибут value="значение". Затем определить массив в котором будут храниться значения и привязать его к чекбоксам директивой v-model.

<template>
	<div>
		<h2>Form inputs</h2>
		
		<label>
			<input type="checkbox" value="instagram" v-model="social"> Instagram
		</label>
		<label>
			<input type="checkbox" value="vk" v-model="social"> Vk
		</label>
		<label>
			<input type="checkbox" value="facebook" v-model="social"> Facebook
		</label>
		
		<hr>
		
		<ul>
			<li v-for="s in social">{{s}}</li>
		</ul>
	</div>
</template>
<script>
export default {
	data() {
		return {
			social: ['vk']
		}
	}
}
</script>

Радио кнопки.
Аналогичны чекбоксам, только модель это не массив, а строка, т.к. можно выбрать только одно значение. Используя vue.js можно не задавать атрибут name, который обычно задается у однотипных радиокнопок. Здесь для однотипных радиокнопок задается одинаковая модель.

<template>
	<div>
		<h2>Form inputs</h2>
		
		<label>
			<input type="radio" value="instagram" v-model="social"> Instagram
		</label>
		<label>
			<input type="radio" value="vk" v-model="social"> Vk
		</label>
		<label>
			<input type="radio" value="facebook" v-model="social"> Facebook
		</label>
		
		<hr>
		
		<p>{{social}}</p>
	</div>
</template>
<script>
export default {
	data() {
		return {
			social: 'facebook'
		}
	}
}
</script>

Селекты.
Выбор значения:
- с помощью атрибута selected: 
<option v-for="s in socialsList" :selected="s == social">{{s}}</option>
- v-model:
<select v-model="social">
	<option v-for="s in socialsList">{{s}}</option>
</select>

<template>
	<div>
		<h2>Form inputs</h2>
		
		<select v-model="social">
			<option v-for="s in socialsList">{{s}}</option>
		</select>
		
		<hr>
		
		<p>{{social}}</p>
	</div>
</template>
<script>
export default {
	data() {
		return {
			social: 'facebook',
			socialsList: ['intagram', 'vk', 'facebook']
		}
	}
}
</script>

Числовой модификатор.
Если указать модификатор number, то vue будет автоматически приводить значение к числовому типу. Если модель нельзя привести к числу (вводить не числовые символы), то модель не будет обновляться (и watch метод вызываться не будет).

<template>
	<div>
		<h2>Form inputs</h2>
		
		<input type="text" v-model.number="age">
		
		<hr>
		
		<p>{{age}}</p>
	</div>
</template>
<script>
export default {
	data() {
		return {
			age: 20,
		}
	},
	watch: {
		age(value) {
			console.log(value);
			console.log(typeof value); // string, если в директиве указан модификатор number, то тип будет number
		}
	}
}
</script>

Создание своего контрола.
Значение передаваемое в компонент через v-model будет в props: ['value']. Чтобы директива v-model изменила значение модели когда оно меняется в компоненте нужно вызвать зарезервированное событие 'input' в компоненте: this.$emit('input', newValue);

Onoff.vue
<template>
	<div>
		<button 
			class="on" 
			:class="{'active': value}"
			@click="onChange(true)"
		>On</button>
		<button 
			class="off" 
			:class="{'active': !value}"
			@click="onChange(false)"
		>Off</button>
	</div>
</template>
<script>
export default {
	props: ['value'],
	methods: {
		onChange(newValue){
			this.$emit('input', newValue);
		}
	}
}
</script>
<style scoped>
button {
	border: none;
	padding: 5px 15px;
	cursor: pointer;
	margin-right: 20px;
	outline: none;
}
button:active {
	box:shadow: inset 1px 1px 2px rgba(0,0,0,.5);
}
.on.active {
	background: green;
	color: #fff;
}
.off.active {
	background: red;
	color: #fff;
}
</style>

App.vue
<template>
	<div>
		<h2>Form inputs</h2>
		
		<app-onoff v-model="switched"></app-onoff>
		<div>
			<h3 v-if="switched">Componet is enabled</h3>
			<h3 v-else>Componet is disabled</h3>
		</div>
	</div>
</template>
<script>
import Onoff from './Onoff.vue'
export default {
	data() {
		return {
			switched: false
		}
	},
	components: {
		appOnoff: Onoff
	}
}
</script>


Валидация форм с vuelidate.
Установка и настройка проекта.
1 Установка bootstrap
2 установить пакет отвечающий за валидацию: Vuelidate
npm install vuelidate --save
Импортировать библиотеку в main.js: import Vuelidate from 'vuelidate';
Подключить библиотеку/плагин в vue.js: Vue.use(library_plugin);
Теперь у каждого инстанса vue будет специальное поле validations, которое позволит работать с валидацией. Это объект в котором ключи это названия валидируемых полей, значение - валидаторы для данного поля { key: validator }. Валидаторы можно найти на оф сайте в разделе builtin validators.
validations: {
    email: {
      required
	}
}
Чтобы использовать валидатор его необходимо привязать внутри шаблона с помощью прослушки событий: нужно поставить какое-либо событие, например input - это событие слушается директивой v-model, и в него нужно передать инициализацию валидации: @input="$v.{валидируемое_поле}.$touch()", $v - специальная переменная, которая отвечает за все валидации, которые есть в компоненте, $touch() - метод который запускает инициализацию валидации:  <input type="email" @input="$v.email.$touch()" v-model="email">
Т.к. используется событие input - валидация происходит при каждом изменении поля (ввод символа). Хорошей практикой является делать валидацию при потере фокуса: @blur="$v.email.$touch()"

Объект $v:
{
  "email": { // поля относящиеся к отдельному инпуту
	"required": false, // false - значит валидация не прошла, required - название валидатора указанное в поле
					   // validations компонента
	"$invalid": true,  // есть ли ошибка валидации
	"$dirty": false, // изменялось ли значение в инпуте
	"$error": false, // есть ли ошибка, изначально ошибок нет, при изменении поля будет показвыть состояние валидации
	"$pending": false, // предназначено для синхронных валидаторов
	"$params": { // параметры валидаторов, например для валидатора длины строки здесь будет указана длина
	  "required": {
		"type": "required"
	  }
	}
  },
  "password": {
    "$params": {
	  "minLength": {
		"min": 6	// минимальная длина строки, переданная при инициализации валидатора в validations
	  }
    }
  }
  "$invalid": true, // поля отвечающие за всю форму в данном компоненте
  "$dirty": false,
  "$error": false,
  "$pending": false,
  "$params": {
  	"email": null
  }
}

Визуальное отображение ошибок
Для отображения состояния инпута будут использоваться bootstrap классы. Не валидным инпутам будет устанавливаться класс is-invalid.

Создание своего валидатора.
Асинхронный валидатор проверки уникальности email. Валидатор определяется в виде функции, принимаемый параметр - новое значение поля, возвращаемое значение должно указавыть валидно состояние (true) или нет (false). Когда для валидации нужно сделать запрос к серверу, можно вернуть из валидатора promise.
validations: {
    email: {
      uniqEmail: function(newEmail){
		if (newEmail === '') return true;
		// эмуляция запроса к серверу
		setTimeout(() => {
		  const value = newEmail !== 'test@mail.ru';
		  resolve(value);
		}, 3000);
	  }
    }
}

Для отправки формы нужно добавить в нее обработчик события сабмит: @submit="onSubmit"

index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>vue-project</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  </head>
  <body>
    <div id="app"></div>
    <script src="/dist/build.js"></script>
  </body>
</html>

main.js
import Vue from 'vue'
import Vuelidate from 'vuelidate' // импорт библиотеки валидации
import App from './App.vue'

Vue.use(Vuelidate)

new Vue({
  el: '#app',
  render: h => h(App)
})

App.vue
<template>
  <div class="container">
    <form class="pt-3" @submit.prevent="onSubmit"> // prevent - чтобы форма не перезагружала страницу
      <div class="form-group">
        <label for="email">Email</label>
        <input
          type="email"
          id="email"
          class="form-control"
		  :class="{'is-invalid': $v.email.$error}"
		  @blur="$v.email.$touch()" // валидация происходит при потере фокуса
          v-model="email"
        >
		<!-- Название поля валидации (required) в объекте валидируемого инпута $v.email ($v.email.required)
			должно совпадать с названием (required) указанынным в validations для данного инпута (email) -->
		<div class="invalid-feedback" v-if="!$v.email.required">Email field is required</div>
        <div class="invalid-feedback" v-if="!$v.email.email">This field should be an email</div>
		<div class="invalid-feedback" v-if="!$v.email.uniqEmail">This email is already exists</div>
      </div>
	  
	  <div class="form-group">
        <label for="password">Password</label>
        <input
          type="password"
          id="password"
          class="form-control"
          :class="{'is-invalid': $v.password.$error}"
          @blur="$v.password.$touch()"
          v-model="password"
        >
        <div class="invalid-feedback" v-if="!$v.password.minLength">
          Min length of password is {{ $v.password.$params.minLength.min }}. Now it is {{ password.length }}.
        </div>
      </div>

      <div class="form-group">
        <label for="confirm">Confirm password</label>
        <input
          type="password"
          id="confirm"
          class="form-control"
          :class="{'is-invalid': $v.confirmPassword.$error}"
          @blur="$v.confirmPassword.$touch()"
          v-model="confirmPassword"
        >
        <div class="invalid-feedback" v-if="!$v.confirmPassword.sameAs">
          Passwords should match
        </div>
      </div>
	  <button class="btn btn-success" type="cubmit" :disabled="$v.$invalid">Submit</button>
	  <pre>
		{{ $v }}
        {{ $v.email }}
	  </pre>
	  
    </form>
  </div>
</template>

<script>
import { required, email, minLength, sameAs } from 'vuelidate/lib/validators'

export default {
  data () {
    return {
	  form: {
	    password: ''
	  }
      email: '',
	  password: '',
	  confirmPassword: ''
    }
  },
  methods: {
	onSubmit() {
	  console.log('Email', this.email);
	  console.log('Password', this.password);
	}
  },
  validations: {
    email: {
      required, // required: required, -  если в es6 ключ и значение объекта совпадают, то ключ можно не указывать
      email, // будет использоваться в шаблоне: $v.email.email
	  // кастомный валидатор
	  uniqEmail: function(newEmail){ // newEmail - новое значение поля
	    //return newEmail !== 'test@mail.ru';
		return new Promise((resolve, reject) => {
			if (newEmail === '') return true; // за валидация пустого значения отвечает вылидатор required, иначе будет задержка 3сек
			// эмуляция запроса к серверу
			setTimeout(() => {
			  const value = newEmail !== 'test@mail.ru';
			  resolve(value);
			}, 3000);
		});
	  }
    },
    password: {
      minLength: minLength(6) // валидаторы могут принимать параметры
    },
    confirmPassword: {
      sameAs: sameAs('password'), // параметром передается название поле которое должно совпадать
	  // так же можно передать функцию, которая будет обозначать, то поле, которое нужно проверять
	  // это нужно чтобы обращаться к полям в отдельном объекте (к полю с любым уровнем вложенности)
	  sameAs: sameAs((vue) => { // параметром передается инстас vue
		return vue.form.password;
	  })
    }
  }
}
</script>



Роутинг с vue-router.
Vue-router - дополнительный пакет, позволяющий делать навигацию между страницами. Страницами в vue.js являются компоненты.
npm install vue-router --save
import VueRouter from 'vue-router'
Vue.use(VueRouter)
Страницы отображаемые в зависимости от выбранного route будут хранится в папке pages. Регистрация роутов в отдельном файле routes.js:
import VueRouter from 'vue-router'
import componetName from './path/to/component'
export default new VueRouter({ 
  routes: [ 
    {
      path: 'path', 
      component: componetName
    }]
})
Роутер регистрируется в экземпляре приложения в поле router:
import router from './routes'
new Vue({
  el: '#app',
  render: h => h(App),
  router: router // регистрация роутера
})

Чтобы указать куда рендерить определенный route используется тег <router-view></router-view> на его место будет рендерится компонент который соответствует текущему rout'y.
В url присутствует хеш # и после него значение rout'a
localhost:8080/#/cars
Хеш можно убрать с помощью параметра в конфигурации роута: 
mode: 'history' - браузер будет сохранять историю посещения различных ссылок.

Создание навигации
При таком методе при нажатии на ссылку страница будет перезагружаться: <a href="/cars">Cars</a>
Чтобы использовать навигацию без перезагрузки страницы есть компонент router-link:
<router-link class="nav-link" :to="'/cars'">Cars</router-link> - рендерится в тег <a>
Атрибуты router-link:
- tag - в него можно передать название тега который нужно использовать в качестве данного компонента(который заменит его).
- active-class - css класс который будет добавляться если ссылка активна
- exact - указывает что нужно точное совпадение адреса чтобы ссылка была активной, иначе совпадение роута будет учитываться по правилу contains 
<router-link tag="li" class="nav-item" exact to="/cars" active-class="active">
    <a class="nav-link">Cars</a>
</router-link>

Указание динамического параметра в роуте: '/car/:id'
Получение значения из роута: this.$router.currentRoute.paramss['id']
Если ссылки на страницу car будут идти из компонента App, то будет работать один переход на страницу, а другие ссылки не будут менять содержимое страницы. Так происходит потому что компонент уже инициализирован и vue не будет его рендерить заново (он уже и так отрисован). Чтобы исправить это нужно 
watch: {
  $route (toR, fromR) {
    this.id = toR.params['id']
  }
}

this.$route === this.$router.currentRoute - более короткая запись

Программная навигация:
this.$router.push('/url'); 
пушим в массив истории браузера новую ссылку, браузер отобразит ссылку, при этом сохранится история

Вложенные роуты.
При нажатии на кнопку "Full info" на странице будет появляться полная информация о машине.
Для объявления вложенных роутов в объекте route есть поле children - массив, элемент - route. Саброуту можно задавать имя, которое будет использоваться для формирования саброута.
<router-link :to="{name: 'имя_саброута', params: {id: id}}"></router-link>

{
  path: '/car/:id',
  component: Car,
  hildren: [
    {
      path: 'full', // localhost:8080/car/10/full
      component: CarFull,
      name: 'имя_саброута'
    }
  ]
}
При этом в родительском компоненте Car нужно указать куда будут рендериться саброуты с помощью директивы router-view.

Передача параметров. 
Передача название и года в query параметрах:
<router-link :to="{name: 'имя_саброута', params: {id: id}, query: {name: 'Mazda', year: 2000}}"></router-link>
Считывание query параметров: {{ $route.query.имя_параметра }} {{ $route.query.name }}
или 
computed: {
  year(){
    return this.$route.query.year;
  }
}

Хэш и скролл.
Хэш - строковое значение, которое пишется через #
localhost:8080/car/3/full?name=Mazda&year=2000#hash
Служит для того, например, чтобы можно было переходить к определенным id. В качестве хэша указывается id элемента к которому нужно перейти. Например:
localhost:8080/car/3/full?name=Mazda&year=2000#scroll
перейдет к элементу с id=scroll: <h6 id="scroll">Hello from the bottom</h6>
Нужно передать значение в параметр hash:
<router-link :to="{name: 'имя_саброута', params: {id: id}, query: {name: 'Mazda', year: 2000}, hash: '#scroll'}"></router-link>
и настроить скрол по странице в файле routes:
scrollBehavior (to, from, savedPosition){
	if (savedPosition){
	  return savedPosition; // сохранить позицию скрола вместо перехода в начало страницы
	}
	
	if (to.hash) {
	  return { selector: to.hash };
	}

	return { // на какие координаты нужно перенести фокус окна браузера
	  x: 0,
	  y: 0
	}
}
Возвращает объект, который говорит vue.js о том, куда нужно проскролить страницу.
to - к какому rout'y переход
from - с какого rout'а переход
savedPosition - при переключении на другие страницы, не происходит перехода, javascript рендерит новые блоки, на одной и той же странице. Чтобы не терять позицую скрола при рендере новой страницы, используется параметр savedPosition.

Редирект.
{
  path: '/none', 
  redirect: '/cars' // редирект к роуту '/cars'
  redirect: {
	name: 'cars' // редирект к именованному роуту cars
  }
}
redirect - можно указывать роут в виде строки, либо в именованный роут.

Отображение ошибки 
{
  path: '*', // для всех не зарегистрированных роутов
  component: ErrorCmp // страница 404
}

Защита роутов.
Guards - позволяют сделать проверку можно ли нажать на данную ссылку (можно ли переходить по роуту).
У каждого роута есть метод beforeEnter, он вызывается перед тем как зайти на роут и чтобы продолжить выполнение роутинга нужно вызвать функцию next(), чтобы отменить переход на роут нужно передать в next параметр false: next(false)
beforeEnter(to, from, next){
  console.log('beforeEnter');
  if (пользователь_авторизован){
    next(); // если не вызывать next(), то перехода на роут не будет (страница не будет рендериться)
  } else {
    next(false); // не осуществлять переход к роуту
  }
}
to - роут куда переходим
from - откуда переходим
next - управляет переходом к роуту

Второй способ контроля над роутингом.
В компоненте есть два метода:
- beforRouteEnter - вызывается перед тем как будет осуществлен переход по роуту;
- beforeRouteLeave - вызывается перед тем как покинуть текуущий роут. Нужно например при заполнении формы переход с подтверждением, перед тем как покинуть страницу в диалоговом окне спрашивается "вы уверены?".
beforeRouteEnter (to, fromR, next){
  console.log('beforeRouteEnter');
  next();
}
beforeRouteLeave (to, fromR, next) {
  console.log('beforeRouteLeave')

  if (window.confirm('Are you sure you want to leave?')) {
    next()
  } else {
    next(false)
  }
}

Ленивая загрузка.
Приложение загружается следующим образом. Оно состоит из нескольких js файлов (vue файлов), при каждом изменении они собираются в один файл, включая vue.js модули.
Можно сделать так чтобы отдельные компоненты загружались при переходе на новый роут, т.е. они исключены из общего файла. Приложение будет грузится быстрее, а остольные модули будут загружать только когда будет переход по их роуту.
Webpack добавляет в общий файл компоненты которые импортированы в файле routes.js. Чтобы этого не происходило нужно удалить импорт компонента. При этом чтобы указать webpack'у откуда загружать данный компонент:

const Cars = resolve => {
  require.ensure(['./pages/Cars.vue'], () => { // указывается физический путь к файлу компонента в проекте
    resolve(
      require('./pages/Cars.vue') // путь к компоненту который нужно подгрузить
    )
  })
}

Фукцию resolve нужно вызвать когда загрузится определенный файл: resolve(requre('путь_к_компоненту')). Чтобы загрузить определенный файл используется функция require.ensure([путь_к_компоненту])

Обычно ленивая загрузка используется для больших модулей, для оптимизации скорости загрузки всего приложения. 

index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>vue-project</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  </head>
  <body>
    <div id="app"></div>
    <script src="/dist/build.js"></script>
  </body>
</html>

<script>
// main.js
import Vue from 'vue'
import App from './App.vue'
import VueRouter from 'vue-router'
import router from './routes'

Vue.use(VueRouter)

new Vue({
  el: '#app',
  render: h => h(App),
  router // регистрация роутера
})

// routes.js
import VueRouter from 'vue-router'
import Home from './pages/Home'
// import Cars from './pages/Cars' // не импортируем компонент Cars чтобы webpack не добавлял его в общий файл
import CarFull from './pages/CarFull'
import ErrorCmp from './pages/Error'

const Cars = resolve => {
  require.ensure(['./pages/Cars.vue'], () => {
    resolve(
      require('./pages/Cars.vue')
    )
  })
}

const Car = resolve => {
  require.ensure(['./pages/Car.vue'], () => {
    resolve(
      require('./pages/Car.vue')
    )
  })

export default new VueRouter({ // экспортируем новый экземпляр класса VueRouter, конструктор принимает объект конфигурации в качестве параметра
  routes: [ // массив маршрутов приложения
    {
      path: '', // localhost:8080
      component: Home
    },
    {
      path: '/cars', // localhost:8080/cars, domain/path
      component: Cars,
	  name: 'cars'
    },
	{
      path: '/car/:id',
      component: Car,
	  children: [
        {
          path: 'full', // localhost:8080/car/10/full
          component: CarFull,
          name: 'carFull',
		  beforeEnter (to, from, next) { // guard
            console.log('beforeEnter')
            next()
          }
        }
      ]
    },
	{
      path: '/none', 
      redirect: '/cars' // редирект
	  redirect: {
		name: 'cars' // редирект к именованному роуту cars
	  }
    },
	{
      path: '*', // для всех не зарегистрированных роутов
      component: ErrorCmp
    }
  ],
  mode: 'history', // убирает # из url
  scrollBehavior (to, from, savedPosition){ // скролл к определенному хэшу
	
	if (savedPosition){
	  return savedPosition; // сохранить позицию скрола вместо перехода в начало страницы
	}
	
	if (to.hash) {
	  return { selector: to.hash };
	}

	return { // на какие координаты нужно перенести фокус окна браузера
	  x: 0,
	  y: 700
	}
  }
})

</script>
App.vue
<template>
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="collapse navbar-collapse">
          <ul class="navbar-nav">
            <li class="nav-item">
              <router-link class="nav-link" to="/">Home</router-link>
            </li>
            <li class="nav-item">
              <router-link class="nav-link" :to="'/cars'">Cars</router-link>
            </li>
			<router-link tag="li" class="nav-item" exact to="/" active-class="active">
              <a class="nav-link">Home</a>
            </router-link>
            <router-link tag="li" class="nav-item" to="/cars" active-class="active">
              <a class="nav-link">Cars</a>
            </router-link>
			
			<router-link tag="li" class="nav-item" to="/car/3" active-class="active">
              <a class="nav-link">Car 3</a>
            </router-link>
            <router-link tag="li" class="nav-item" to="/car/4" active-class="active">
              <a class="nav-link">Car 4</a>
            </router-link>
			
          </ul>
        </div>
      </nav>

      <router-view></router-view>
    </div>
</template>

<script>
  export default {}
</script>

pages/home.vue
<template>
    <h1>Home page</h1>
</template>

<script>
  export default {

  }
</script>

<style scoped>

</style>

pages/cars.vue
<template>
  <div>
    <h1>Cars page</h1>

    <ul>

      <router-link
        tag="li"
        v-for="car in 5"
        :to="'/car/' + car"
        :key="car" // специальный ключ для оптимизации
      >
        <a>Car {{ car }}</a>
      </router-link>

    </ul>
  </div>
</template>

<script>
  export default {}
</script>

<style scoped>

</style>

pages/car.vue
<template>
    <h1>Car id {{ id }}</h1>
	
	<button class="btn btn-sm btn-default mb-2" @click="goBackToCars">Back</button>
	<br>
	<!-- Вложенные роуты -->
    <router-link
      class="btn btn-info mt-2"
      tag="button"
      :to="'/car/' + id + '/full'"
    >
      Full info
    </router-link>
	
    <router-link
      class="btn btn-info mt-2"
      tag="button"
      :to="{name: 'carFull', params: {id: id}}"
    >
      Full info
    </router-link>
	<!-- Передача query параметров -->
	<router-link
      class="btn btn-info mt-2"
      tag="button"
      :to="{name: 'carFull', params: {id: id}}, query: {name: 'Mazda', year: 2000}, hash: '#scroll'"
    >
      Full info
    </router-link>
    <hr>

    <router-view></router-view>
</template>

<script>
  export default {
    data () {
      return {
        // id: this.$router.currentRoute.params['id'], // считывание значения парамтра id из роута
        id: this.$route.params['id'] // 
      }
    },
	methods:{
	  goBackToCars(){
	    this.$router.push('/cars'); // пушим в массив истории браузера новую ссылку, браузер отобразит ссылку
	  }
	},
    watch: {
      $route (toR, fromR) {
        this.id = toR.params['id']
      }
    },
	beforeRouteLeave (to, fromR, next) {
      console.log('beforeRouteLeave')

      if (window.confirm('Are you sure you want to leave?')) {
        next()
      } else {
        next(false)
      }
    }
  }
</script>

<style scoped>

</style>

pages/carFull.vue
<template>
    <div>
      <h4>Car name: {{ $route.query.name }}</h4>
      <h5>Car year: {{ year }}</h5>
	  
	  <div class="scroll"></div>
      <!-- переход к элементу с помощью хэша в url: /path#scroll -->
      <h6 id="scroll">Hello from the bottom</h6>

      <div class="scroll"></div>
    </div>
</template>

<script>
  export default {
    computed: {
	  year(){
	    return this.$route.query.year;
	  }
	},
	beforeRouteEnter (to, fromR, next){
	  console.log('beforeRouteEnter');
	  next();
	}
  }
</script>

<style scoped>
  .scroll {
    width: 100px;
    height: 1000px;
    background: #ccc;
  }
</style>

pages/Error.vue
<template>
    <h1 style="color: red;">404 Error</h1>
</template>

<script>
  export default {

  }
</script>

<style scoped>

</style>


Работа с сервером с vue-resource.
Настройка приложения.
Для работы с сервером в Vue.js можно использовать любую доступную библиотеку или писать нативный код. Например можно подключить jquery и использовать его ajax, или axious, которая позволяет удобно работать с ajax запросами. 
Для использования с Vue.js была специально разработана библиотека, которая позволяет удобно работать с асинхронными запросами: vue-resource. 

npm install vue-resource --save

В качестве сервера можно взять готовое решение, например firebase, или локальным сервером для разработки json 
server. 

npm install -g json-server
npm install --save-dev json-server

Устанавливается глобально и локально для разработки проекта.

package.json
"scripts": {
  "dev": "cross-env NODE_ENV=development webpack-dev-server --open --hot",
  "build": "cross-env NODE_ENV=production webpack --progress --hide-modules",
  "server": "json-server --watch db.json"  // запуск json-server
}

нужно создать файл db.json в корне проекта (в папке гда package.json)
{
  "cars": []
}

Для запуска приложения запускаем frontend: npm run dev
Вторым процессом (в другом терминале) нужно запустить json-server: npm run server

Создание объектов POST.
this.$http.post('http://localhost:3000/cars', car)
.then(response => {
  return response.json() // возвращает данные созданного объекта без вспомогательной (технической) информации
})
.then(newCar => {
  console.log(newCar)
})
Отправляется два запроса:
1. OPTIONS - frontend проверял доступен ли сервер.
2. POST - создание объекта.

Получение объектов GET.
this.$http.get('http://localhost:3000/cars')
.then(response => {
  return response.json()
})
.then(cars => {
  this.cars = cars
})
Также в $http есть еще два метода:
PUT - изменяет данные;
DELETE - удаляет.

Использование resource.
vue-resource предоставляет инструмент удобный для работы с однотипными сущностями: $resource.
created () {
  this.resource = this.$resource('http://localhost:3000/cars')
}

Глобальная настройка.
Установка базового url для всех запросов: Vue.http.options.root = 'http://localhost:3000/'

Интерсепторы.
Интерсепторы обрабатывают запросы отправляемые на сервер и могут их модифицировать (изменять method, headers ...).
Например добавление токена аутентификации в каждом запросе:
Vue.http.interceptors.push(request => {
  request.headers.set('Auth', 'RAND TOKEN ' + Math.random())
})

<script>
db.json
{
  "cars": [{
      "name": "Ford",
      "year": 2018,
      "id": 1
    },
    {
      "name": "Mazda",
      "year": 2015,
      "id": 2
    }]
}

main.js
import Vue from 'vue'
import VueResource from 'vue-resource' // подключение библиотеки vue-resource
import App from './App.vue'

Vue.use(VueResource)  // использовать vue-resource

Vue.http.options.root = 'http://localhost:3000/'

Vue.http.interceptors.push(request => {
  request.headers.set('Auth', 'RAND TOKEN ' + Math.random())
})

new Vue({
  el: '#app',
  render: h => h(App)
})
</script>

App.vue
<template>
  <div class="container pt-2">
    <div class="form-group">
      <label for="name">Car name</label>
      <input type="text" id="name" class="form-control" v-model.trim="carName">
    </div>

    <div class="form-group">
      <label for="year">Car year</label>
      <input type="text" id="year" class="form-control" v-model.number="carYear">
    </div>

    <button class="btn btn-success" @click="createCar">Create car</button>
	<button class="btn btn-primary" @click="loadCars">Load cars</button>
	
	<hr>

    <ul class="list-group">
      <li
        class="list-group-item"
        v-for="car of cars"
        :key="car.id"
      >
        <strong>{{ car.name }}</strong> - {{ car.year }}
      </li>
    </ul>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        carName: '',
        carYear: 2018,
		cars: [],
		resource: null // будет использоваться для получения и создания машин
      }
    },
    methods: {
      createCar () {
        const car = {
          name: this.carName,
          year: this.carYear
        }

        this.$http.post('http://localhost:3000/cars', car)
          .then(response => {
			console.log(response);
            return response.json()
          })
          .then(newCar => {
            console.log(newCar)
          })
      },
	  loadCars () {
        this.$http.get('http://localhost:3000/cars')
          .then(response => {
            return response.json()
          })
          .then(cars => {
            this.cars = cars
          })
      },
	  
	  // создание и сохранение с использованием $resource
	  createCar () {
        const car = {
          name: this.carName,
          year: this.carYear
        }

        this.resource.save({}, car)
      },
      loadCars () {
        this.resource.get().then(response => {
		  console.log(response);
		  response.json()
		})
        .then(cars => this.cars = cars)
      }
    },
	created () {
      this.resource = this.$resource('http://localhost:3000/cars')
	  this.resource = this.$resource('cars') // если указан базовый url в глобальной конфигурации vue-resource
    }
  }
</script>


Работа с данными с vuex.
Установка vuex.
Имеется три компонента:
App - родительский, передает counter в компонент Counter. Слушает кастомное событие counterUpdated компонента Actions и увеличивает значение counter на нужную величину;
Counter - получает значение счетчика (counter) и выводит его;
Actions - при клике на определенную кнопку эмитится событие counterUpdated с параметром 1 или -1.
Взаимодействие дочерних комонентов происходит через родительский. Для решения данной проблемы можно использовать шину событий, но данная шины быстро засорится: при большом количестве взаимодействий будет много разных событий за которыми будет сложно уследить. Поэтому не подходит для больших приложений (можно запутаться в коде).
Для решения данной проблемы в Vue.js имплиментирована логика redux в библиотеке vuex. Это дополнительный модуль, который предоставляет общую шину и общий state всего приложения. Это объект, который описывает состояние всего приложения. Все компоненты будут иметь к нему доступ (т.е. будут иметь доступ к общему состоянию приложения). Взаимодействие с данными будет осуществляться через прослойку - store.

Установка: npm install vuex --save
Чтобы его использовать создается новая папка store, в ней создается файл index.js. В этом файле нужно настроить объект store.

<script>
// src/main.js
import Vue from 'vue'
import App from './App.vue'
import store from './store' // index.js можно не дописывать, webpack будет по умолчанию использовать файл index.js т.е. эквивалентно import store from './store/index.js'

new Vue({
  el: '#app',
  store: store, // подключение store к приложению
  render: h => h(App)
})

// src\store\index.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex); // подключение плагина

// нужно экспортировать результат работы конструктора библиотеки vuex
export default new Vuex.Store({ // в конструктор передается объект конфигурации

})

</script>

src/App.vue
<template>
  <div class="container text-center pt-5">
    <app-counter :counter="counter"></app-counter>
    <app-actions @counterUpdated="counter += $event"></app-actions>
  </div>
</template>

<script>
  import Counter from './Counter'
  import Actions from './Actions'

  export default {
    data() {
      return {
        counter: 0
      }
    },
    components: {
      appCounter: Counter,
      appActions: Actions
    }
  }
</script>

src/Counter.vue
<template>
    <h2>Counter {{counter}}</h2>
</template>

<script>
  export default {
    props: ['counter']
  }
</script>


src/Actions.vue
<template>
    <div>
      <button class="btn btn-success" @click="updateCounter(1)">Add</button>
      <button class="btn btn-danger" @click="updateCounter(-1)">Subtract</button>
    </div>
</template>

<script>
  export default {
    methods: {
      updateCounter(val) {
        this.$emit('counterUpdated', val)
      }
    }
  }
</script>


Использование state.
Теперь отрефакторим взаимодействие между дочерними компонентами.
Конфигурация store
// src\store\index.js
export default new Vuex.Store({
  state: { // описывает все состояние приложения
    counter: 10
  }
})

использование state
src/Counter.vue
computed: {
  counter () {
    return this.$store.state.counter
  }
}
Теперь в компоненте App не нужно передавать параметр counter в компонент Counter: <app-counter></app-counter>

Использование getters
Если перед выводом с данными хранящимися в state нужно произвести вычисления (изменить эти данные) и эти данные используются в двух разных компонентах, то получается дублирование кода.
return this.$store.state.counter * (7 - 2 * (5 + 4)) // дублирование кода
Вычисление нужно сделать в store и отдать компонентам готовое значение. Для этого используются getters:
export default new Vuex.Store({
  state: {
    counter: 0
  },
  getters: {
    computedCounter (state) {
      return state.counter * (7 - 2 * (5 + 4))
    }
  }
})
использование: this.$store.getters.computedCounter;
Хотя getter является функцией, вызывать ее не надо, vuex сам вызовет ее.

Использование mutations 
Это функции, которые позволяют мутировать state (сеттеры). Параметры:
- state
- какие либо данные, нельзя передавать асинхронные события.
new Vuex.Store({
  mutations: {
    changeCounter (state, payload) {
		setTimeout // нельзя
      state.counter += payload
    }
  }
})
В mutations нельзя делать setTimeout или обращения к серверу. Для этого есть actions.

использование: this.$store.commit('mutationName', data)
this.$store.commit('changeCounter', val)


Использование actions.
Для асинхронных действий (работы с сервером) используются actions.
actions: {
  asyncChangeCounter (context, payload) {  
    setTimeout(() => {
      context.commit('changeCounter', payload.counterValue)
    }, payload.timeoutDelay)
  }
}
 
Использование
this.$store.dispatch('asyncChangeCounter', {
  counterValue: val,
  timeoutDelay: 1200
})

Mutations и getters должны быть простыми, в actions происходит вся основная логикаф.

<script>
// src\store\index.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: { // описывает все состояние приложения
    counter: 10
  },
  mutations: {
    changeCounter (state, payload) { // возможно только синхронные операции
      state.counter += payload
    }
  },
  actions: {
    asyncChangeCounter ({commit}, payload) { // {commit} - деконструкция объекта context
      setTimeout(() => { // асинхронные действия 
        commit('changeCounter', payload.counterValue)
      }, payload.timeoutDelay)
    }
  },
  getters: {
    computedCounter (state) {
      return state.counter * 10 // произвести действия над данными в store, чтобы избежать дублирования кода в компонентах
    }
  }
})

</script>

src/Counter.vue
<template>
    <h2>Counter {{counter}}</h2>
</template>

<script>
  export default {
    computed: {
      counter () {
        return this.$store.state.counter // использование общего state приложения
		
		return this.$store.state.counter * (7 - 2 * (5 + 4)) // дублирование кода
		return this.$store.getters.computedCounter; // использовать getters чтобы избежать дубилрования
      }
    }
  }
</script>

<style scoped>

</style>

src/Actions.vue
<template>
    <div>
      <button class="btn btn-success" @click="updateCounter(1)">Add</button>
      <button class="btn btn-danger" @click="updateCounter(-1)">Subtract</button>
    </div>
</template>

<script>
  export default {
    methods: {
      updateCounter(val) {
        this.$store.state.counter += val // изменение обшего состояния
		this.$store.commit('changeCounter', val) // использование mutations
		this.$store.dispatch('asyncChangeCounter', { // использование actions
          counterValue: val,
          timeoutDelay: 1200
        })
      }
    }
  }
</script>

<style scoped>

</style>

src/SecondCounter.vue
<template>
  <h2>Second Counter: {{counter}}</h2>
</template>

<script>
  export default {
    computed: {
      counter () {
		return this.$store.state.counter * (7 - 2 * (5 + 4)) // дублирование кода
		return this.$store.getters.computedCounter; // использовать getters чтобы избежать дубилрования
      }
    }
  }
</script>

<style scoped>

</style>

src/App.vue
<template>
  <div class="container text-center pt-5">
    <app-counter></app-counter>
	<app-second-counter></app-second-counter>
	<hr>
    <app-actions></app-actions>
  </div>
</template>

<script>
  import Counter from './Counter'
  import Actions from './Actions'
  import SecondCounter from './SecondCounter'
  
  export default {
    components: {
      appCounter: Counter,
      appActions: Actions,
	  appSecondCounter: SecondCounter
    }
  }
</script>

Оптимизация с помощью модулей. 
Декомпозиция файла store на множество модулей. Создание модуля для counter'а.

<script>
// src/store/counter.js

export default {
  state: {
    counter: 0
  },
  mutations: {
    changeCounter (state, payload) {
      state.counter += payload
    }
  },
  actions: {
    asyncChangeCounter ({commit}, payload) {
      setTimeout(() => {
        commit('changeCounter', payload.counterValue)
      }, payload.timeoutDelay)
    }
  },
  getters: {
    computedCounter (state) {
      return state.counter * 10
    }
  }
}


// src/store/index

import Vue from 'vue'
import Vuex from 'vuex'
import counter from './counter'

Vue.use(Vuex)

export default new Vuex.Store({
  modules: { // регистрация модулей
    counter // регистрация функционала counter
  },
  state: {
    title: 'Hello from store'
  },
  getters: {
    title (state) {
      return state.title + '!!!'
    }
  }
})

</script>